"""
Nmap Wrapper - Network Reconnaissance

This module wraps the Nmap tool for network discovery and port scanning.
It provides a standardized interface for reconnaissance activities.
"""

import nmap
import subprocess
import re
from typing import Dict, List, Optional, Any
from datetime import datetime
import time

from wrappers.base_wrapper import (
    BaseWrapper, ToolResult, Finding, ToolStatus, SeverityLevel
)


class ScanType:
    """Predefined Nmap scan types"""
    QUICK = "-T4 -F"  # Fast scan, top 100 ports
    STEALTH = "-sS -T2"  # SYN stealth scan, slow
    AGGRESSIVE = "-A -T4"  # OS detection, version detection, scripts, traceroute
    COMPREHENSIVE = "-sS -sV -O -p- -T4"  # All ports, service/OS detection
    DEFAULT = "-sV -sC"  # Service version, default scripts
    DISCOVERY = "-sn"  # Ping scan (no port scan)
    UDP = "-sU -F"  # UDP scan, top ports


class NmapWrapper(BaseWrapper):
    """
    Wrapper for Nmap - Network Mapper
    
    Features:
    - Multiple scan profiles (quick, stealth, aggressive)
    - Service version detection
    - OS fingerprinting
    - Script scanning (NSE)
    - Host discovery
    """
    
    def __init__(self, config: Optional[Dict] = None):
        """Initialize Nmap wrapper"""
        super().__init__(config)
        self.scanner = None
        if self.is_available:
            try:
                self.scanner = nmap.PortScanner()
            except Exception as e:
                print(f"Warning: Could not initialize python-nmap: {e}")
    
    def _get_tool_name(self) -> str:
        return "Nmap"
    
    def _check_tool_availability(self) -> bool:
        """Check if Nmap is installed"""
        try:
            result = subprocess.run(
                ['nmap', '--version'],
                capture_output=True,
                text=True,
                timeout=5
            )
            return result.returncode == 0
        except (FileNotFoundError, subprocess.TimeoutExpired):
            return False
    
    def get_version(self) -> Optional[str]:
        """Get Nmap version"""
        try:
            result = subprocess.run(
                ['nmap', '--version'],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode == 0:
                # Extract version from output like "Nmap version 7.94"
                match = re.search(r'Nmap version (\S+)', result.stdout)
                if match:
                    return match.group(1)
        except Exception:
            pass
        return None
    
    def get_capabilities(self) -> List[str]:
        """List of scanning capabilities"""
        return [
            "host_discovery",
            "port_scanning",
            "service_detection",
            "os_fingerprinting",
            "vulnerability_scanning",
            "script_scanning"
        ]
    
    def execute(self, target: str, options: Optional[Dict] = None) -> ToolResult:
        """
        Execute Nmap scan
        
        Args:
            target: IP address, hostname, or CIDR range
            options: Scan options
                - scan_type: str (quick|stealth|aggressive|comprehensive|default)
                - custom_flags: str (custom Nmap flags)
                - ports: str (port specification, e.g., "1-1000,8080")
                - timeout: int (scan timeout in seconds)
        
        Returns:
            ToolResult with scan findings
        """
        if not self.is_available:
            return ToolResult(
                tool_name=self.tool_name,
                target=target,
                status=ToolStatus.FAILED,
                error_message="Nmap is not available on this system"
            )
        
        if not self.validate_target(target):
            return ToolResult(
                tool_name=self.tool_name,
                target=target,
                status=ToolStatus.FAILED,
                error_message="Invalid target format"
            )
        
        # Parse options
        options = options or {}
        scan_type = options.get('scan_type', 'default')
        custom_flags = options.get('custom_flags')
        ports = options.get('ports', '1-10000')  # Top 10000 ports by default
        timeout = options.get('timeout', 600)  # 10 minute default
        
        # Determine scan arguments
        if custom_flags:
            scan_args = custom_flags
        else:
            scan_profiles = {
                'quick': ScanType.QUICK,
                'stealth': ScanType.STEALTH,
                'aggressive': ScanType.AGGRESSIVE,
                'comprehensive': ScanType.COMPREHENSIVE,
                'default': ScanType.DEFAULT,
                'discovery': ScanType.DISCOVERY,
                'udp': ScanType.UDP
            }
            scan_args = scan_profiles.get(scan_type, ScanType.DEFAULT)
        
        # Add ports if not a discovery scan
        if '-sn' not in scan_args:
            scan_args += f" -p {ports}"
        
        # Execute scan
        start_time = time.time()
        result = ToolResult(
            tool_name=self.tool_name,
            target=target,
            status=ToolStatus.RUNNING,
            metadata={
                'scan_type': scan_type,
                'scan_args': scan_args,
                'ports': ports
            }
        )
        
        try:
            print(f"[*] Starting Nmap scan: {target}")
            print(f"[*] Arguments: {scan_args}")
            
            # Run the scan
            self.scanner.scan(hosts=target, arguments=scan_args, timeout=timeout)
            
            duration = time.time() - start_time
            
            # Parse results
            findings = self._parse_nmap_results(self.scanner)
            
            result.status = ToolStatus.COMPLETED
            result.duration = duration
            result.findings = [f.to_dict() for f in findings]
            result.raw_output = str(self.scanner.csv())
            result.metadata['hosts_scanned'] = len(self.scanner.all_hosts())
            result.metadata['hosts_up'] = len([h for h in self.scanner.all_hosts() 
                                              if self.scanner[str(h)].state() == 'up'])
            
            print(f"[✓] Scan completed in {duration:.2f} seconds")
            print(f"[✓] Found {len(findings)} findings")
            
        except KeyboardInterrupt:
            result.status = ToolStatus.FAILED
            result.error_message = "Scan interrupted by user"
            print("\n[!] Scan interrupted")
            
        except subprocess.TimeoutExpired:
            result.status = ToolStatus.TIMEOUT
            result.error_message = f"Scan exceeded timeout of {timeout} seconds"
            print(f"\n[!] Scan timeout after {timeout} seconds")
            
        except Exception as e:
            result.status = ToolStatus.FAILED
            result.error_message = str(e)
            print(f"\n[!] Scan failed: {e}")
        
        finally:
            result.duration = time.time() - start_time
        
        return result
    
    def _parse_nmap_results(self, scanner: nmap.PortScanner) -> List[Finding]:
        """Parse Nmap scan results into Finding objects"""
        findings = []
        
        print(f"[DEBUG] Parsing results for {len(scanner.all_hosts())} hosts")
        
        for host in [str(h) for h in scanner.all_hosts()]:
            print(f"[DEBUG] Processing host: {host}")
            
            # Get host info with error handling
            try:
               host_info = scanner[str(host)]
            except (KeyError, AssertionError) as e:
               print(f"[DEBUG] Could not access host {host}: {e}")
               continue
            
            # Skip down hosts
            if host_info.state() != 'up':
                print(f"[DEBUG] Host {host} is down")
                continue
            
            print(f"[DEBUG] Host {host} is UP")
            print(f"[DEBUG] Available protocols: {host_info.all_protocols()}")
            
            # Port Scanning
            for proto in host_info.all_protocols():
                print(f"[DEBUG] Protocol: {proto}")
                
                # Get ports - handle both dict and list
                try:
                    lport = host_info[proto].keys()
                    ports = list(lport)
                except:
                    ports = []
                
                print(f"[DEBUG] Found {len(ports)} ports on {proto}")
                
                for port in ports:
                    port_info = host_info[proto][port]
                    state = port_info.get('state', 'unknown')
                    
                    print(f"[DEBUG] Port {port}: {state}")
                    
                    if state == 'open':
                        service = port_info.get('name', 'unknown')
                        version = port_info.get('version', '')
                        product = port_info.get('product', '')
                        
                        severity = self._assess_port_severity(port, service)
                        
                        service_desc = f"{product} {version}".strip() or service
                        
                        finding = Finding(
        finding_id=str(f"{host}_{proto}_{port}"),  # Explicitly string
        title=str(f"Open Port: {port}/{proto.upper()} - {service}"),  # Explicitly string
        description=str(f"Service: {service_desc}"),  # Explicitly string
        severity=severity,  # Already SeverityLevel enum
        port=int(port),  # Explicitly int
        service=str(service),  # Explicitly string
        affected_component=str(host),  # Explicitly string
        evidence={
            'state': str(state),
            'protocol': str(proto),
            'service': str(service),
            'product': str(product),
            'version': str(version),
        }
    )
                        findings.append(finding)
                        print(f"[DEBUG] Added finding for port {port}")

      
        print(f"[DEBUG] Total findings: {len(findings)}")
        return findings
    
    def _assess_port_severity(self, port: int, service: str) -> SeverityLevel:
        """Assess security implications of an open port"""
        # Critical services (common attack vectors)
        critical_services = {'telnet', 'rexec', 'rlogin', 'ftp'}
        critical_ports = {23, 512, 513, 514, 21}
        
        # High-risk services
        high_risk_services = {'ssh', 'rdp', 'vnc', 'mysql', 'postgresql', 'mongodb'}
        high_risk_ports = {22, 3389, 5900, 3306, 5432, 27017}
        
        # Medium-risk services
        medium_risk_services = {'http', 'https', 'smb', 'smtp'}
        medium_risk_ports = {80, 443, 445, 25}
        
        if service.lower() in critical_services or port in critical_ports:
            return SeverityLevel.CRITICAL
        elif service.lower() in high_risk_services or port in high_risk_ports:
            return SeverityLevel.HIGH
        elif service.lower() in medium_risk_services or port in medium_risk_ports:
            return SeverityLevel.MEDIUM
        else:
            return SeverityLevel.LOW
    
    def parse_output(self, raw_output: str) -> List[Finding]:
        """
        Parse raw Nmap output (not typically used with python-nmap)
        
        This method is here for compliance with BaseWrapper interface
        """
        # This would be used if we were parsing Nmap XML or text output directly
        # For now, we use _parse_nmap_results() which works with the scanner object
        return []
    
    def quick_host_discovery(self, target: str) -> List[str]:
        """
        Perform quick host discovery (ping scan)
        
        Returns:
            List of IP addresses that are up
        """
        result = self.execute(target, {'scan_type': 'discovery'})
        
        if result.status == ToolStatus.COMPLETED and self.scanner:
            return [host for host in self.scanner.all_hosts() 
                   if self.scanner[str(host)].state() == 'up']
        return []


# Testing
if __name__ == "__main__":
    print("=" * 60)
    print("Nmap Wrapper Test")
    print("=" * 60)
    
    wrapper = NmapWrapper()
    
    print(f"\nTool Name: {wrapper.tool_name}")
    print(f"Available: {wrapper.is_available}")
    print(f"Version: {wrapper.get_version()}")
    print(f"Capabilities: {', '.join(wrapper.get_capabilities())}")
    
    if wrapper.is_available:
        print("\n" + "=" * 60)
        print("Example: Quick scan of localhost")
        print("=" * 60)
        
        # Test scan (localhost only for safety)
        result = wrapper.execute(
            target="127.0.0.1",
            options={'scan_type': 'quick'}
        )
        
        print(f"\nStatus: {result.status.value}")
        print(f"Duration: {result.duration:.2f}s")
        print(f"Findings: {len(result.findings)}")
        
        # Print findings
        for finding in result.findings[:5]:  # Show first 5
            f = Finding(**finding)
            print(f"\n  [{f.severity.value.upper()}] {f.title}")
            print(f"  {f.description}")
    else:
        print("\n[!] Nmap not available - install with: sudo apt-get install nmap")
